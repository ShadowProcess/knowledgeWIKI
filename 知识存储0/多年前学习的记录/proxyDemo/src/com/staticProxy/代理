代理虽然和装饰模式有点相似；

但是功能不一样

装饰模式强调是：对功能进行增强；
代理模式强调是：对功能进行控制；

=======================
1.代理模式
    代理模式作用：
        屏蔽真实行为的访问，让程序更加安全
        可以对真实行为的调用进行控制

    通过一个案例：来说明代理的实现以及代理的作用
        代理模式的实现：
            1.代理类与被代理类要实现同一个接口
            2.在代理类中持有被代理对象
            3.在代理类中调用被代理的行为

==========================================
AOP: 面向方面的编程
    Aop的底层实现就是通过动态代理来做到的。

2.动态代理
    它就是在代理模式基础上发展的，它不是在对单一的类型进行代理
     而是可以对任意的一个实现[接口]的类的对象做代理。

3.动态代理实现
    有两种方式：
        1.通过jdk中提供的Proxy类来实现
            这种方式要求，被代理类必须实现接口，
            简单说，只能为接口做代理

        2.通过cglib来实现
            它不要求，实现接口
            [cglib是通过继承来实现的]
代码实现：
Proxy类中有一个方法
newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler);

参数：
    loader:
        要求：传递的是被代理类的类加载器ClassLoader
        类加载器怎么获取：
            得到其Class对象。在Class类中提供一个方法 getClassLoader（）

    interfaces:
        要求：得到被代理对象所实现的接口的所有的Class对象
        怎样获取所有实现接口的Class对象？
        得到其Class对象，在Class类中提供一个方法， getInterfaces();
        它返回的是Class[] ，就代表所实现接口的所有Class对象

    h:
        它的类型是InvocationHandler，这是一个接口
        InvocationHandler是代理实例的调用处理程序实现的接口
        这个接口作用就是控制真实行为的访问

 InvocationHandler接口中有一方法invoke;
 public Object invoke();