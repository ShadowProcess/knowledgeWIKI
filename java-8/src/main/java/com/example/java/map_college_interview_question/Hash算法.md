/**
 * 先来看下什么是哈希？
 * 哈希又叫“散列”，是将任意对象或者数据根据指定的哈希算法运算之后，输出一段固定长度的数据，通过这段固定长度的数据来作为这个对象或者数据的特征，这就是哈希。
 * 这句话可能比较绕口，举个例子。
 * <p>
 * 在一篇文章中有10000个单词，需要查找这10000个单词中是否存在“hello”这个单词，最直观的办法当然是遍历这个数组，每个单词跟“hello”进行比较，
 * 最坏的情况下可能要比较10000次才能找到需要的结果，如果这个数组无限大，那要比较的次数就会无限上升。那有没有更快速的查找途径呢？
 * 答案就是哈希表。首先将这10000个单词根据一种指定的哈希算法计算出每个单词的哈希值，然后将这些哈希值映射到一个长度为100的数组内，
 * 如果映射足够均匀的话大概数组的每个值对应100个单词，这样我们在查找的时候只需要计算出“hello”的哈希值对应在数组中的索引，
 * 然后遍历这个位置中对应的100个单词即可。当映射的数组足够大，比如10000，哈希算法足够好，映射一对一，每个哈希值都不相同，
 * 这样理论上最优可以在一次查找就得道想到的结果，最坏的查找次数就是数组的每个位置所对应的单词数。这样相比较直接遍历数组要快速的多。
 * <p>
 * 哈希可以大大提高查找指定元素的效率，但受限于哈希算法的好坏。一个好的哈希算法可以将元素均匀分布在固定长度的数组中，
 * 相应的如果算法不够好，对性能就会产生很大影响。
 * <p>
 * 那有没有一个算法可以让任意一个给定的元素，都输出一个唯一的哈希值呢？答案是暂时没有发现这样的算法。如果不能每个元素都对应到一个唯一的哈希值，
 * 就会产生多个元素对应到一个哈希值的情况，这种情况就叫“哈希冲突”。
 * <p>
 * static final int hash(Object key) {
 * int h;
 * return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
 * }
 * 复制代码在这段代码就是用来获取哈希值的，其中首先获取了key的hashCode，这个hashCode如果元素有重新实现hashCode函数则会使用自己实现的hashCode，
 * 在没有自己实现时，hashCode函数大部分情况下会返回元素在内存中的地址，但也不是绝对的，需要根据各个JVM的内在实现来判断，
 * 但大部分实现就算没直接使用内存地址，也和内存地址存在一定的关联。
 */