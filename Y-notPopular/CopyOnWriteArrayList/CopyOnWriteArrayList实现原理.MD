优缺点分析：了解了CopyOnWriteArrayList的实现原理，分析它的优缺点及使用场景就很容易了。

#优点：
读操作性能很高，因为无需任何同步措施，比较适用于读多写少的并发场景。Java的list在遍历时，
若中途有别的线程对list容器进行修改，则会抛出ConcurrentModificationException异常。
而CopyOnWriteArrayList由于其"读写分离"的思想，遍历和修改操作分别作用在不同的list容器，
所以在使用迭代器进行遍历时候，也就不会抛出ConcurrentModificationException异常了

#缺点：
缺点也很明显，
一是内存占用问题，毕竟每次执行写操作都要将原容器拷贝一份，数据量大时，对内存压力较大，可能会引起频繁GC；
二是无法保证实时性，Vector对于读写操作均加锁同步，可以保证读和写的强一致性。
而CopyOnWriteArrayList由于其实现策略的原因，写和读分别作用在新老不同容器上，
>在写操作执行过程中，读不会阻塞但读取到的却是老容器的数据。
 

#内存占用问题。
因为 CopyOnWrite 的写时复制机制，所以在进行写操作的时候，内存里
会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器
里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以
有两份对象内存）。如果这些对象占用的内存比较大，比如说 200M 左右，那么再写入 100M
数据进去，内存就会占用 300M，那么这个时候很有可能造成频繁的 Yong GC 和 Full GC。之
前我们系统中使用了一个服务由于每晚使用 CopyOnWrite 机制更新大对象，造成了每晚 15
秒的 Full GC，应用响应时间也随之变长。
针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，
如果元素全是 10 进制的数字，可以考虑把它压缩成 36 进制或 64 进制。或者不使用
CopyOnWrite 容器，而使用其他的并发容器，如 ConcurrentHashMap。

#数据一致性问题。
CopyOnWrite 容器只能保证数据的最终一致性，不能保证数据的实时
一致性。所以如果你希望写入的的数据，马上能读到，请不要使用 CopyOnWrite 容器。
