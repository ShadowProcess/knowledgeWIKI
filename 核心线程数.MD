#核心线程数怎么设置？
合理的设置线程池的线程数需要针对不同的任务类型而定，任务类型可以分为CPU密集型、IO密集型和混合型。
1）CPU密集型
```
CPU密集型指的是线程处理任务时，CPU参与计算的时间比较多，这种情况下，如果设置的线程数过多，会增加上下文的切换次数，带来额外的开销。
线程数的设定公式是：
线程数=（cpu核心数+1）。
```

2）IO密集型
```
IO密集型是指在处理任务时，IO过程所占用的时间较多，在这种情况下，线程数的计算方法可以分为两种：
方法一：线程数=cpu核心数*2，cpu所占用时间不多，可让cpu在等待IO的时候去处理其他任务，充分利用cpu。
方法二：线程等待时间比例越多，需要更多的线程，而线程cpu所占时间越多，则需要更少线程数。
线程数=((线程等待时间+线程cpu时间) / 线程cpu时间) * cpu核心数。

(所用时间/真正工作时间) * CPU核心数
```

3）混合型
```
对于混合型，可以将任务划分成cpu密集型任务与IO密集型任务，分别针对这两种任务使用不同的线程池去处理。
```


#分布式id？
```
先说第一位，long类型的数字是有符号的，第一位是0就是正数，1是负数，我们生成的id必然要正数，所以第一位可以确定为0不变。
剩下的63位分成三大部分，第一部分占41位，用来表示时间，什么时间后面会详细介绍。第二部分占10位，用来表示程序所在机器的信息，
剩下的第三部分占12位，填充的是一个序列，可以理解为递增数字，这样前面的时间和机器数字如果都一样的话，用序列的区别来生成不同的id。

上面的三大块信息转换成数字，填充到63位当中，基本可以保证任何时间任何机器生产的任何id不重复，可以推理出，时间和序列都是不可控的，
但是机器信息是我们可以控制的，也就是说设置好机器信息是分布式id不重复的关键。
```


#arraylist线程为什么不安全？

add元素时，实际做了两个大的步骤：
* 判断elementData数组容量是否满足需求
* 在elementData对应位置上设置值

这样也就出现了第一个导致线程不安全的隐患，在多个线程进行add操作时可能会导致elementData数组越界。具体逻辑如下：
* 列表大小为9，即size=9
* 线程A开始进入add方法，这时它获取到size的值为9，调用ensureCapacityInternal方法进行容量判断。
* 线程B此时也进入add方法，它获取到size的值也为9，也开始调用ensureCapacityInternal方法。
* 线程A发现需求大小为10，而elementData的大小就为10，可以容纳。于是它不再扩容，返回。
* 线程B也发现需求大小为10，也可以容纳，返回。
* 线程A开始进行设置值操作， elementData[size++] = e 操作。此时size变为10。
* 线程B也开始进行设置值操作，它尝试设置elementData[10] = e，而elementData没有进行过扩容，它的下标最大为9。于是此时会报出一个数组越界的异常ArrayIndexOutOfBoundsException.

另外第二步 elementData[size++] = e 设置值的操作同样会导致线程不安全。从这儿可以看出，这步操作也不是一个原子操作，它由如下两步操作构成：
* 		elementData[size] = e;
* 		size = size + 1;
在单线程执行这两条代码时没有任何问题，但是当多线程环境下执行时，可能就会发生一个线程的值覆盖另一个线程添加的值，具体逻辑如下：
* 		列表大小为0，即size=0
* 		线程A开始添加一个元素，值为A。此时它执行第一条操作，将A放在了elementData下标为0的位置上。
* 		接着线程B刚好也要开始添加一个值为B的元素，且走到了第一步操作。此时线程B获取到size的值依然为0，于是它将B也放在了elementData下标为0的位置上。
* 		线程A开始将size的值增加为1
* 		线程B开始将size的值增加为2
这样线程AB执行完毕后，理想中情况为size为2，elementData下标0的位置为A，下标1的位置为B。而实际情况变成了size为2，elementData下标为0的位置变成了B，下标1的位置上什么都没有。并且后续除非使用set方法修改此位置的值，否则将一直为null，因为size为2，添加元素时会从下标为2的位置上开始。

#static 和 final 理解？
static可以在不创建类实例时使用
final可以修饰类，方法，变量（成员变量和局部变量） 
修饰类，终态类，类不能被继承。 
修饰方法，方法不能被重写。 
修饰变量，变量只能被赋值一次，不能被重新赋值，其实就是一个常量。


#类为什么要是static的？
static加在类上，表示这是一个静态资源，不管创建（new）多少对象，只有一份。



