#=====================================方法1(旧的，废弃的)==================================================================
```
Redis Setnx（set if not exists）命令在指定的 key 不存在时，为 key 设置指定的值。

加锁(第一步)：
SETNX KEY_NAME VALUE
加锁(第二步)：
EXPIRE <KEY> <TTL> : 将键的生存时间设为 ttl 秒
PEXPIRE <KEY> <TTL> :将键的生存时间设为 ttl 毫秒
EXPIREAT <KEY> <timestamp> :将键的过期时间设为 timestamp 所指定的秒数时间戳
PEXPIREAT <KEY> <timestamp>: 将键的过期时间设为 timestamp 所指定的毫秒数时间戳.

解锁：
DEL KEY_NAME
```
设置成功，返回 1 。 
设置失败，返回 0 。

#====================================方法2===================================================================
redis版本升级到2.1以上，Redis增加了<SET key value NX PX 3000>命令
然后使用java中对应的setIfAbsent方法直接设置过期时间：
- setIfAbsent是java中的方法《setIfAbsent就是<SET key value NX PX 3000>的封装》，可以查看源码注释确定这件事
- <SET key value NX PX 3000>是redis2.1版本后提供的命令
```
加锁：
Boolean add = redisTemplate.opsForValue().setIfAbsent(key, value, timeout, unit);

解锁：
Boolean delete = redisTemplate.opsForValue().getOperations().delete(key);
```

#=====================================方法3==================================================================
使用 Redssion 做分布式锁，不需要明确指定 value ，框架会帮我们生成一个由 UUID 和 加锁操作的线程的 threadId 用冒号拼接起来的字符串。

使用hash结构存储锁：
```
__________________________________
key   |    value1    |   value2  |
锁    |  UUID:线程id  |   重入次数  |
----------------------------------
```

watchDog：锁自动延时机制（只有使用默认超时时间30秒才会生效；你设置了超时时间，看门狗就不生效了，因为如果你设置了5秒，这怎么搞呢，所以框架编写者规避了这个问题）
```
应用题：key 默认的过期时间是 30s，每过 30s/3 的时候会去进行续命操作，那么每当 key 的 ttl（剩余时间）返回多少的时候，会进行续命操作？

答：由题干可知，30s/3 = 10s。于是得公式到：30s - 10s = 20s。

所以，每当 key 的 ttl（剩余时间）为 20 的时候，则进行续命操作，重新将 key 的过期时间设置为默认时间 30s。
注意我上面一直强调的是默认时间 30s。

-------------------------------------原则上，你不能设置60秒，又让看门狗生效---------------------------------------------------------------------------

因为这个时间是可以修改的，比如我们想要修改为 60s，于是 internalLockLeaseTime 就变成了 60000 了：
附加题：阅读上面材料后，当默认时间被修改为 60s 后，那么每当 key 的 ttl（剩余时间） 返回多少的时候，会进行续命操作？

答：由题可得，时间每过 60s/3 = 20s 时，任务会被触发，看门狗进行工作。

所以，60s - 20s = 40s。每当 key 的 ttl 返回 40 时，会进行续命操作。
```
