mysql可以打开锁统计，通过以下语句打开mysql的锁的统计；
该类监控机制默认是关闭状态，分析问题需要查看监控日志时再开启。
建议分析问题后，将监控关闭；否则，每15秒输出一次INNODB运行状态信息到错误日志，会使用日志变得特别大。
```sql
set GLOBAL innodb_status_output_locks=ON;
set GLOBAL innodb_status_output=ON;
```


#先建表
```sql
CREATE TABLE `test_dup` (
`id` int(11) NOT NULL AUTO_INCREMENT,
`num` int(10) unsigned DEFAULT NULL,
`name` varchar(45) DEFAULT NULL,
PRIMARY KEY (`id`),
UNIQUE KEY `num_index` (`num`)
) ENGINE=InnoDB AUTO_INCREMENT=138 DEFAULT CHARSET=utf8;

-- 已有数据：
insert into test_dup values(1,1,'hi');
insert into test_dup values(2,2,'dcdcdf');
insert into test_dup values(30,3,'dcdcdf2');
insert into test_dup values(34,20,'dcdcdf473894739');
insert into test_dup values(33,50,'43494');
insert into test_dup values(58,200,'dcdcdf');
```

涛哥的操作是这样:
多个线程，每个线程执行许多这样的操作，但是保证每个线程执行的num是绝对不一样的：

#1.第一个事务执行以下语句，不提交
```sql
start transaction;
insert into test_dup(num,name) values(41,'no') on duplicate key update name='dcdcdf4738';
```

#2.第二个事务执行以下语句，不提交
```sql
start transaction;
insert into test_dup(num,name) values(40,'no') on duplicate key update name='dcdcdf4738';
```

#3.在第一个事务中，注释调原来语句，继续执行以下语句
```sql
insert into test_dup(num,name) values(38,'no') on duplicate key update name='dcdcdf4738';
```
#(3.)执行完，发现(2.)控制台提示【Deadlock found when trying to get lock; try restarting transaction】


````分析：
在第二步的时候我们运行show engine innodb status;查看锁的情况发现：

事务1持有：IX锁（表锁），gap x锁（在num_index上num=50之前的gap），gap x锁（在num_index上num=41之前的gap），num_index上的record lock（num=41），

事务2持有：IX锁（表锁），gap x锁（在num_index上num=41之前的gap），insert intention lock（在等待事务1的第二个gap锁）。

如果这时候第三步执行，那么事务1的insert intention也会等待事务2的gap锁，死锁形成。
````

继续测试分析：如果事务1执行的num是41，事务2执行的num大于41，而不是小于或者等于41，那么继续执行事务1,的num=38，不会导致死锁,说明是间隙锁导致的问题。


mysql可以打开锁统计，通过以下语句打开mysql的锁的统计
```sql
set GLOBAL innodb_status_output_locks=ON;
set GLOBAL innodb_status_output=ON;
```
