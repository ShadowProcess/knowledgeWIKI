#10进制小数转2进制原理:
```
可以采用乘2取整法，即将小数部分乘以2，然后取整数部分，剩下的小数部分继续乘以2，然后取整数部分，
剩下的小数部分又乘以2，一直取到小数部分为零为止。如果永远不能为零，就同十进制数的四舍五入一样，
按照要求保留多少位小数时，就根据后面一位是0还是1，取舍，如果是零，舍掉，如果是1，向入一位。
换句话说就是0舍1入。读数要从前面的整数读到后面的整数。
```

下面验证一下,对于0.1转换成二进制表达：
0.1 * 2 = 0.2  ---------------取0
0.2 * 2 = 0.4  ---------------取0
0.4 * 2 = 0.8  ---------------取0
0.8 * 2 = 1.6  ---------------取1
0.6 * 2 = 1.2  ---------------取1
0.2 * 2 = 0.4  ---------------取0
0.4 * 2 = 0.8  ---------------取0
0.8 * 2 = 1.6  ---------------取1
0.6 * 2 = 1.2  ---------------取1
0.2 * 2 = 0.4  ---------------取0
0.4 * 2 = 0.8  ---------------取0
0.8 * 2 = 1.6  ---------------取1
0.6 * 2 = 1.2  ---------------取1
0.2 * 2 = 0.4  ---------------取0
0.4 * 2 = 0.8  ---------------取0
0.8 * 2 = 1.6  ---------------取1
0.6 * 2 = 1.2  ---------------取1
0.2 * 2 = 0.4  ---------------取0
0.4 * 2 = 0.8  ---------------取0
0.8 * 2 = 1.6  ---------------取1
0.6 * 2 = 1.2  ---------------取1
。。。
10进制小数转换2进制结果：0.0001100110011001100110011001100110011001100110011001101(后面省略)



1）规范化表达

下面来验证一下，对于0.1，转化成二进制表达

0.00011001100110011....

规范化表达（类似于十进制的科学记数法）

1.100110011001100 x 2^-4

其中符号位0。

2）指数的表达

接下来的指数部分应该是-4，可是实际上存储的是是0111 1011，实际上这是移码的表达，移的是127，也就是指数部分存储的最终内容是127+(-4)=123，也就是0111 1011

3）有效部分截断时的四舍五入
有效数位部分按道理来讲是 1100 1100 1100 的循环直至截断，由于规范化表达，使得小数点左边的一位一定是1，所以这一位被省略了，剩下的就是1001 1001 1001的循环，由于有效只能表达23位，所以应该是（灰色表达要被丢弃的部分）

100 1100 1100 1100 1100 1100 1100 1100...
————————————————
细心的人会注意到最后,四位并不是1100，而是1101，这是因为截断尾数时采用了四舍五入的方式，如果截断的部分第一位为1，说明截断部分的数值大于或等于上一位的1/2，因此向前进一位所表达的误差会更小，因此被截断的 1100 1100 1100.. 会对上一位产生进位影响，所以最后四位是1100 + 1 = 1101

对于double型也是一样的方式，值得注意的是代码中显示的是 9999 9999a 3fb9 9999，

但实际上这个double的表达是 3fb9 9999 9999 9999a，代码打印的结果是因为这里采用大端存储的缘故
————————————————
