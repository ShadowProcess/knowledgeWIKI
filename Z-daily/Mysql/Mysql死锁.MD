```
MySQL InnoDB存储引擎提供了如下几种锁：
（1）共享/排他锁（S/X锁）
共享锁（S Lock）：允许事务读取一行数据，多个事务可以拿到一把S锁（即读读并行）；
排他锁（X Lock）：允许事务删除或更新一行数据，多个事务有且只有一个事务可以拿到X锁（即写写/写读互斥）；
（2）意向锁（Intention Lock）
意向锁是一种表级别的锁，意味着事务在更细的粒度上进行加锁。

意向共享锁（IS Lock）：事务想要获得一张表中某几行的共享锁；
意向排他锁（IX Lock）：事务想要获得一张表中某几行的排他锁；
```


MySQL死锁
死锁是指两个或两个以上事务在执行过程中因争抢锁资源而造成的互相等待的现象。

发生死锁的3个条件
```
1. >= 2个事务
2. 不同方向
3. 相同锁资源
```


解决死锁的方法:
- 程序层面：
  保持多个事务对锁资源的获取顺序一致

- 超时等待：
即当两个事务互相等待时，当一个事务等待时间超过设置的阈值时，就将其回滚，另外事务继续进行。
（缺点：如果回滚的事务更新了很多行，占用了较多的undo log，
那么在回滚的时候花费的时间比另外一个正常执行的事务花费的时间可能还要多，就不太合适）；

- wait-for graph（等待图）：
死锁碰撞检测，是一种较为主动的死锁检测机制，要求数据库保存锁的信息链表和事务等待链表两部分信息，
通过这两个部分信息构造出一张图，在每个事务请求锁并发生等待时都会判断是否存在回路，
如果在图中检测到回路，就表明有死锁产生，这时候InnoDB存储引擎会选择回滚undo量最小的事务。
————————————————




