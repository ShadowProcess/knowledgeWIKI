今天无意中看到一个问题：    
为什么抽象类不能实例化？    
很多人的答案都是再说使用抽象类的好处，但是并没有回答为什么不能实例化？  
这个过程就像是在回答：为什么公鸡不能下蛋？然后回答是使用公鸡可以打鸣。

答案是: 规定。
为什么我这么理解，原因有以下几点。


1.回归问题最初， 我们为什么要实例化？
```
我们先逆向思维来考虑，从面向对象的思想来看：
我们需要完成实现一个功能，而功能中的方法，是由对象来调用的，因此我们需要对象，
因此我们需要实例化。那么回归本问题，什么是抽象类？

抽象：就是不具体的意思。类是对对象的具体描述，而抽象类不具体，没有方法体，
（提供的成员不足以生成一个具体对象），那么就无法生成一个不具体的对象。
就好比，你可以实例化一个苹果，但你不能实例化一个水果（这个现实中存在的实物）。
```

2.内存考虑：
```
对象实例化的时候，关键字new向JVM申请内存，
这个类的成员（成员变量，成员方法）会被保存到内存中。
而抽象类，没有具体的成员（成员变量，成员方法），没办法准确分配内存。
```

3.现实逻辑：
```
按照现实逻辑，抽象是从现实实物的抽离，
总结，比如定义一个动物类接口。
这个接口是所有动物所共有的特点组成在一起，
但是并不能组成现实中真真正正存在的物种。那么为什么要有抽象类？
```

4.设计层面：
```
为了实现多态，当某些类只希望作为父类使用，
不希望被实例化。也就是我们从上层设计角度，
就不希望有些类被实例化。当我们进行设计的时候需要尽量依赖父类，
越向上层的类越稳定，不容易被修改。
```

综上所述：现实逻辑，面向对象，设计，内存都不希望我们实例化抽象类，所以 编译器规定不能实例化。

```
Student s = new Student("这是抽象类");
编译器提示错误： 'Student' is abstract; cannot be instantiated
```

关于抽象类可以看这篇文章<https://blog.csdn.net/qq_42859864/article/details/103208481>

还需要注意的一点是实例化和有没有构造方法没有关系，构造方法只是初始化对象的，new关键字向JVM申请内存来创建对象的。