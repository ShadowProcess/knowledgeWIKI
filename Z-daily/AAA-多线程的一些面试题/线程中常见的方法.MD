注意：  
第一：
```
hotspot虚拟机对notofy()的实现并不是我们以为的随机唤醒, 而是“先进先出”的顺序唤醒!
```
第二：
```
除了notify()，还有一个方法 notifyAll()也可起到类似作用，唯一的区别在于，
调用 notifyAll()方法将把因调用该对象的 wait()方法而阻塞的所有线程一次性全部解除阻塞。
当然，只有获得锁的那一个线程才能进入可执行状态。
```
————————————————

join()      
```
让主线程“等待”子线程结束后才能继续执行
```


sleep()  
```
作用是让当前线程休眠（正在执行的线程主动让出cpu，然后cpu就可以去执行其他任务），
即当前线程会从“运行状态”进入到“休眠（阻塞）状态”。
sleep()会指定休眠时间，线程休眠的时候会大于或者等于该休眠时间，
当时间过后该线程重新由“阻塞状态”变为“就绪状态”，从而等待cpu的调度执行，
注意：sleep方法只是让出了cpu的执行权，并不会释放同步资源锁。
```


wait()   
```
让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。

wait()会使“当前线程”进入等待，并且会释放到它所占用的“锁标志”
```


notify()    
```
notify在源码的注释中说到notify选择唤醒的线程是任意的，但是依赖于具体实现的jvm；
ObjectMonitor.cpp源码中实际上是将_WaitSet中的第一个元素进行出队操作,
这也说明了notify是个顺序操作, 具有公平性.
```


notifyAll() 
```
唤醒在此对象监视器上等待的所有线程
```


yield()
```
作用是让步，它能够让当前线程从“运行状态”进入到“就绪状态”，
从而让其他等待线程获取执行权，但是不能保证在当前线程调用yield()之后，
其他线程就一定能获得执行权，也有可能是当前线程又回到“运行状态”继续运行，
注意：这里我将上面的“具有相同优先级”的线程直接改为了线程，
很多资料都写的是让具有相同优先级的线程开始竞争，但其实不是这样的，
优先级低的线程在拿到cpu执行权后也是可以执行，
只不过优先级高的线程拿到cpu执行权的概率比较大而已，并不是一定能拿到。

举个例子：一帮朋友在排队上公交车，轮到Yield的时候，他突然说：我不想先上去了，咱们大家来竞赛上公交车。
然后所有人就一块冲向公交车，有可能是其他人先上车了，也有可能是Yield先上车了。
```
