1. 控制失效时间，避免同时失效。比如写入时，过期时间在一个范围内随机
    ---当然了，这样避免不了redis down机所造成的同时失效（避免down机又是怎么高可用的问题了）

2. 常规的缓存更新，可以加锁。
简单来说，就是当读取缓存失败需要去db读取时，通过加锁保证只有一个请求去db进行读取和更新，其它的请求可以直接返回或等待。
    ---这种加锁，解决的是某个key失效后，大量请求都同时读取该key的情况（比如全局的计数之类）。
    ---如果是上面提到的donw机的场景，那已经是一场”雪崩“了，就要根椐实际场景来操作了。。。
    
所以，如果是预案，既然是缓存，就要想尽办法，避免整体失效（因为一旦整体失效，而db又无法承受大量请求的话，则只能是降级服务了）