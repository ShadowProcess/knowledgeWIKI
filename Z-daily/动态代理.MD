```
feign
jpa
mybatis
以上这种只写接口，不写实现的方式，皆是用动态代理实现的；
```

JDK动态代理：利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。
CGlib动态代理：利用ASM(开源的Java字节码编辑库，操作字节码)开源包，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。

注意：
```
Cglib不能对声明为final的方法进行代理，因为Cglib原理是动态生成被代理类的子类;
(final在Java中规定，目前我们使用 final 去修饰方法的唯一原因，
就是想把这个方法锁定，意味着任何继承类都不能修改这个方法的含义，
也就是说，被 final 修饰的方法不可以被重写，不能被 override。)
```

区别：  
- JDK代理只能对实现接口的类生成代理；
- CGlib是针对类实现代理，对指定的类生成一个子类，并覆盖其中的方法生成代理。
