mysql可以打开锁统计，通过以下语句打开mysql的锁的统计；
该类监控机制默认是关闭状态，分析问题需要查看监控日志时再开启。
建议分析问题后，将监控关闭；否则，每15秒输出一次INNODB运行状态信息到错误日志，会使用日志变得特别大。
```sql
set GLOBAL innodb_status_output_locks=ON;
set GLOBAL innodb_status_output=ON;
```

```
MySQL的锁系统：shared lock和exclusive lock(共享锁和排他锁，也叫读锁和写锁，即read lock和write lock)

共享锁【S锁】
又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。
这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

排他锁【X锁】
又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。
这保证了其他事务在T释放A上的锁之前不能再读取和修改A。
```






问题背景：Deadlock found when trying to get lock; try restarting transaction

# 创建数据库deadlock,然后重现过程：
```sql
create table t
(
    c1    int primary key,
    c2    int,
    c3    int,
    c4    int,
    unique index i_c2(c2),
    index i_c3(c3)
);
insert into t
values (10, 11, 12, 13),
       (20, 21, 22, 23),
       (30, 31, 32, 33),
       (40, 41, 42, 43);

-- 表名t，c1列为主键，c2列为唯一索引，c3列为普通索引
-- 数据库隔离级别：RR
-- 数据库版本：mysql 5.7.21
```
```
场景说明：批量插入场景，多个会话同时插入，每一个会话插入多条数据。
场景描述：在唯一索引c2的间隙（31，41）插入3条不同记录。会话1先插入1条c2=36，会话2接着插入1条c2=35，最后会话1插入1条c2=34。这3次操作插入的值都不一样
```


用Navicat工具，打开ABC两个窗口，

#会话1：
```sql
start transaction;
insert into t values(50,36,52,53) on duplicate key update c2=36;
```

#会话2：
```sql
start transaction;
insert into t values(60,35,62,63) on duplicate key update c2=35;
```

#此时会话2阻塞了，我们可以查看一下锁信息，另外开启一个会话3：
```sql
show engine innodb status;
```
![avatar](img/死锁1.png)


#注释会话1原来的语句，并在会话1执行。
```sql
insert into t values(70,34,72,73) on duplicate key update c2=34;
```

可以看到最新的1条死锁信息，就是我们刚刚产生的死锁

#我们切换到会话3，查看锁状态
```sql
show engine innodb status;
```
![avatar](img/死锁2.png)




