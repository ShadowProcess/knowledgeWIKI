问题背景：Deadlock found when trying to get lock; try restarting transaction

# 创建数据库deadlock,然后重现过程：
```sql
create table t
(
    c1    int primary key,
    c2    int,
    c3    int,
    c4    int,
    unique index i_c2(c2),
    index i_c3(c3)
);
insert into t
values (10, 11, 12, 13),
       (20, 21, 22, 23),
       (30, 31, 32, 33),
       (40, 41, 42, 43);

-- 表名t，c1列为主键，c2列为唯一索引，c3列为普通索引
-- 数据库隔离级别：RR
-- 数据库版本：mysql 5.7.21
```
```
场景说明：批量插入场景，多个会话同时插入，每一个会话插入多条数据。
场景描述：在唯一索引c2的间隙（31，41）插入3条不同记录。会话1先插入1条c2=36，会话2接着插入1条c2=35，最后会话1插入1条c2=34。这3次操作插入的值都不一样
```


用Navicat工具，打开ABC两个窗口，

#会话1：
```sql
start transaction;
insert into t values(50,36,52,53) on duplicate key update c2=36;
```

#会话2：
```sql
start transaction;
insert into t values(60,35,62,63) on duplicate key update c2=35;
```

#这个时候会话2阻塞了，我们可以查看一下锁信息，另外开启一个会话3：
```sql
show engine innodb status;
```
![avatar](img/死锁1.png)


#注释会话1原来的语句，并在会话1执行。
```sql
insert into t values(70,34,72,73) on duplicate key update c2=34;
```

可以看到最新的1条死锁信息，就是我们刚刚产生的死锁

#我们切换到会话3，查看锁状态
```sql
show engine innodb status;
```
![avatar](img/死锁2.png)




